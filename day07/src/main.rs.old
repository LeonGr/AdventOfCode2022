fn read_input() -> Vec<String> {
    let input = include_str!("../input");
    input.to_string().lines().map(|s| s.to_string()).collect()
}

#[derive(Debug)]
enum Command {
    Ls(Directory),
    Cd(String),
}

#[derive(Debug, Clone)]
struct File {
    name: String,
    size: usize,
}

#[derive(Debug, Clone)]
struct Directory {
    name: String,
    directories: Vec<Directory>,
    files_size: usize,
}

// fn parse(input: &[String]) -> Vec<Command> {
    // let mut output = vec![];

    // let mut i = 0;

    // let mut current_dir_name = String::new();

    // loop {
        // if i >= input.len() {
            // break;
        // }

        // let line = &input[i];
        // println!("line: {}", line);

        // if line.contains("cd") {
            // println!("cd");
            // let dir = line.split_once("cd ").unwrap().1.to_string();

            // current_dir_name = dir.clone();

            // let command = Command::Cd(dir);

            // output.push(command);
        // } else {
            // println!("ls");
            // let mut directories = vec![];
            // let mut files = vec![];

            // let mut j = i + 1;
            // loop {
                // if j >= input.len() {
                    // break;
                // }

                // let ls_line = &input[j];
                // println!("ls_line: {}", ls_line);

                // if ls_line.starts_with('$') {
                    // break;
                // }

                // let parts = ls_line.split_once(' ').unwrap();
                // match parts.0 {
                    // "dir" => {
                        // let directory = Directory {
                            // name: parts.1.to_string(),
                            // directories: vec![],
                            // files: vec![],
                        // };

                        // directories.push(directory);
                    // }
                    // size => {
                        // let file_size = size.parse().expect("expected filesize");

                        // let file = File {
                            // name: parts.1.to_string(),
                            // size: file_size,
                        // };

                        // files.push(file);
                    // }
                // }

                // j += 1;
            // }

            // i = j - 1;

            // let directory = Directory {
                // name: current_dir_name.to_string(),
                // files,
                // directories,
            // };

            // let command = Command::Ls(directory);
            // output.push(command);
        // }

        // i += 1;
    // }

    // output
// }

fn size(dir: &Directory) -> usize {
    let direcory_size: usize = dir.directories
        .iter()
        .map(|d| size(d))
        .sum();

    dir.files_size + direcory_size
}

fn test(input: &Vec<String>) -> Vec<Directory> {
    let mut stack: Vec<Directory> = vec![];
    let mut directories = vec![];
    let mut input = input.clone();
    input.push(String::from("$ cd .."));

    let mut i = 0;
    loop {
        if i >= input.len() {
            break;
        }

        let line = &input[i];
        println!("line: {}", line);

        if line.starts_with("$") {
            if line.contains("cd") {
                if line.contains("..") {
                    let last = stack.pop().unwrap();
                    // if last.name == "/" {
                        // stack.push(last);
                        // continue;
                    // }
                    let parent: &mut Directory = stack.last_mut().unwrap();
                    parent.directories.push(last.clone());
                    directories.push(last);
                } else {
                    let path = line.split_once("cd ").unwrap().1.to_string();

                    let dir = Directory {
                        name: path,
                        directories: vec![],
                        files_size: 0,
                    };

                    stack.push(dir);
                }
            } else {
                let mut dir_file_size = 0;

                let mut j = i + 1;
                loop {
                    if j >= input.len() {
                        break;
                    }

                    let ls_line = &input[j];

                    if ls_line.starts_with('$') {
                        break;
                    }

                    println!("ls_line: {}", ls_line);

                    if !ls_line.starts_with("dir") {
                        let file_size: usize = ls_line.split_once(' ').unwrap().0.parse().expect("expected filesize");

                        dir_file_size += file_size;
                    }

                    j += 1;
                }

                let last: &mut Directory = stack.last_mut().unwrap();
                last.files_size += dir_file_size;

                i = j - 1;
            }
        }

        i += 1;
    }


    directories.append(&mut stack);

    directories
}

// fn get_all_directories(input: &[Command]) -> Vec<Directory> {
    // let mut stack: Vec<Directory> = vec![];
    // let mut directories = vec![];

    // for command in input {
        // // println!("{:?}", command);
        // match command {
            // Command::Ls(dir) => {
                // // let dirs = dir.directories.clone();
                // let files = dir.files.clone();
                // let last: &mut Directory = stack.last_mut().unwrap();
                // // last.directories = dirs;
                // last.files = files;
            // },
            // Command::Cd(path) => {
                // match path.as_str() {
                    // ".." => {
                        // let last = stack.pop().unwrap();
                        // if last.name == "/" {
                            // stack.push(last);
                            // continue;
                        // }
                        // let parent: &mut Directory = stack.last_mut().unwrap();
                        // parent.directories.push(last.clone());
                        // directories.push(last);
                    // },
                    // path => {
                        // let dir = Directory {
                            // name: path.to_string(),
                            // directories: vec![],
                            // files: vec![],
                        // };

                        // stack.push(dir);
                        // // println!("stack: {:?} ###", stack);
                    // }
                // }
            // },
        // }
    // }

    // let last = stack.pop().unwrap();
    // let parent: &mut Directory = stack.last_mut().unwrap();
    // parent.directories.push(last.clone());
    // directories.push(last);

    // directories.append(&mut stack);

    // directories
// }

// fn part1(input: &[Command]) -> usize {
    // let directories = get_all_directories(input);

    // println!("dirs:");
    // for dir in &directories {
        // println!("{:?}: {}", dir.name, size(&dir));
    // }

    // directories.iter().filter(|&d| size(d) < 100000).map(|d| size(d)).sum()
// }

// fn part2(input: &[Command]) -> usize {
    // let needed = 30000000;
    // let total = 70000000;
    // let mut directories = get_all_directories(input);

    // let root = directories.iter().filter(|&d| d.name == "/").collect::<Vec<&Directory>>();
    // let root = root.first().unwrap();
    // // let root_size = 40268565;
    // let root_size = size(*root);

    // println!("root: {}", root_size);
    // let available = total - root_size;
    // println!("available: {}", available);

    // let to_delete = needed - available;

    // println!("to delete: {}", to_delete);
    // let mut min = usize::MAX;
    // // let mut delete_dir: Option<Directory> = None;

    // for dir in directories {
        // let size = size(&dir);
        // if size >= to_delete && size < min {
            // min = size;
            // // delete_dir = Some(dir);
        // }
    // }

    // min
// }

fn main() {
    let lines = read_input();
    for dir in test(&lines) {
        println!("{:?}: {}", dir.name, size(&dir));
    }
    // let parsed = parse(&lines);

    // println!("{:?}", parsed);
    // for command in &parsed {
        // println!("{:?}", command);
    // }

    // println!("part1: {}", part1(&parsed));
    // println!("part2: {}", part2(&parsed));
}
